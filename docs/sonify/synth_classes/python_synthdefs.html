<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>sonify.synth_classes.python_synthdefs API documentation</title>
<meta name="description" content="Classes for different synthdefs - this is where new classes will be added to interface with precompiled synthdefs made in supercollider
Each class â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sonify.synth_classes.python_synthdefs</code></h1>
</header>
<section id="section-intro">
<p>Classes for different synthdefs - this is where new classes will be added to interface with precompiled synthdefs made in supercollider
Each class inherits synth.precompute or synth.realtime depending on how data is sent to sc and how the synthdef is written (see synth.py documentation for more info)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Classes for different synthdefs - this is where new classes will be added to interface with precompiled synthdefs made in supercollider 
Each class inherits synth.precompute or synth.realtime depending on how data is sent to sc and how the synthdef is written (see synth.py documentation for more info)

&#34;&#34;&#34;

from . import synth
from sonify.tools.spectro_harmonic_preprocessing import get_Pxx_blob_features
import numpy as np

class Pxx_blob(synth.precompute):
        &#34;&#34;&#34;
        Feature based spectrogram sonification. Synth similar to what was submitted to cancelled ICAD 2020.
        Harmonic bands are extracted using peak detection and sonified with sin osc
        Spectrogram envelop extracted and sonified using noise sweep

        Attributes
        -----------------
        synthdef : str
                Synthdef saced in sc.sc.synthdefpath - precompiled in supercollider. Default here is Pxx_blob which is similar to the ICAD 2020 submission synth
        
        freqs : 1-D numpy array  
                Range of frequencies form spectrogram - used for feature detection functions

        bins : 1-D numpy array
                Time bins - needs to be the same as what is in the synthdef (36 bins is convention for spectrograms). Each time bin will have a unique sound, and they are played in sequence to make the sonification

        pxx : 2-D numpy array 
                Spectrogram to be sonified (dimensions freqs.shape x bins.shape)

        active : 2-D numpy array 
                Denotes which oscilators to keep on - the same non-zero entries as pitches. This holds whether the pitch is on or off (dimensions freqs.shape x bins.shape)
 
        noise : 1-D numpy array
                Array of cutoff frequencies for the LPF with noise input in supercolider. Computed based on spectrogram envelope.

        pitches : 2-D numpy array
                Denotes the pitches of the active oscillators. Harmonic sounds are forced by assigning notes of major triad for stacked harmonics. See preprocessing.getPitches for more info

        labels : 2-D numpy array
                for visualizing pitch blob groups

        relativePeakHeight: 2-D numpy array
                Height of detected spectrogram bands with respect to overall power falloff. Used to control panning in synthdef
        &#34;&#34;&#34;

        def __init__(self, pxx, freqs, bins):
                super().__init__()
                self.synthdef = &#39;Pxx_blob&#39;
                self.freqs = freqs
                self.bins  = bins

                self.pxx = pxx
                self.active = None
                self.noise = None
                self.pitches = None
                self.labels = None
                self.relativePeakHeight = None

                self.generate_synthlist()

        def send_to_sc(self):
                &#34;&#34;&#34;
                Detect features and send the matricies to supercollider
                Important to note that you cannot iterate over numpy arrays to send to sc -- must be converted to a list first
                &#34;&#34;&#34;
                self.active,self.noise,self.pitches, self.labels, self.relativePeakHeight  =  get_Pxx_blob_features(self.pxx.copy(),self.freqs)

                freqs = self.freqs.tolist()
                cut_row = self.noise.tolist()
                n_bins = len(self.bins)

                for idx,syn in enumerate(self.synthlist):
                        if idx &lt; self.freqs.shape[0]:
                                pxx_row = self.relativePeakHeight[idx].tolist()
                                act_row = self.active[idx].tolist()                             #which harmonics are active
                                pitch_row = self.pitches[idx].tolist()                          #pitch of active harmonics
                                syn.timestretch = self.looptime

                                param_names     = [&#39;cut_&#39;,&#39;pxx_&#39;,&#39;act_&#39;,&#39;ph_&#39;]
                                param_values    = [cut_row,pxx_row,act_row,pitch_row]

                        #exception (i.e., if there are more synths in the synthlist than there are spectrogram dimensions) if envelope synth (eg., click) is to be appeneded to the end of synthlist 
                        else:
                                param_name = &#39;cut_&#39;
                                param_value = cut_row

                        for param_name,param_value in zip(param_names,param_values): #this loop replaces the hardcoding of each time bin. This is where we set the class attributes on the sc server
                                names = [f&#39;{param_name}{str(step).zfill(3)}&#39; for step in range(n_bins)]
                                for name,value in zip(names,param_value):
                                        syn.__setattr__(name,value)


class flat_q_with_spectro_env(synth.realtime):

        def __init__(self,q_array,r_array,pxx,bins,freqs):
                super().__init__()
                self.synthdef = &#39;flat_q_with_spectro_env&#39;

                self.q_array = q_array
                self.r_array = r_array
                
                self.pxx = pxx
                self.bins = bins

                self.n_positions = q_array.shape[0]
                
                positions = np.linspace(0,1,int(self.n_positions/2) + 1) #temp variable
                self.positions = np.append(positions,-1*np.flip(positions[1:-1]))

                self.n_timesteps = q_array.shape[1]

                _, self.envelope,_,_,_ = get_Pxx_blob_features(self.pxx.copy(),freqs) #this is probably an uncessary bottleneck - just compute envelope directly in future

                #rescale and interpolate cutoff frequency envelope over all video frames
                self.envelope /=2
                self.interp_envelope = np.interp(np.linspace(0,self.bins.max(),self.n_timesteps),self.bins,self.envelope)

                #just to maintain naming convention - needed for synthlist generation.. sor for the confusion 
                self.freqs = np.zeros(self.n_positions)
                
                self.generate_synthlist()

                #this doesn&#39;t need to be updated in realtime, only computed once, so we&#39;ll do it here
                for each in range (self.n_positions):
                        self.synthlist[each].theta = float(self.positions[each])

        def send_to_sc(self,timestep):
                &#34;&#34;&#34;
                Unlike precompute - this is called multiple times in the loop as recording progresess. 
                Done for each step in range self.n_timesteps -&gt; see synth.realtime for more
                Assumes all computed on python client side
                &#34;&#34;&#34;
                for position,syn in enumerate(self.synthlist):
                        syn.q = float(self.q_array[position][timestep]) #+ interp_envelope[timestep])
                        syn.r = float(self.r_array[position][timestep])
                        syn.e = float(self.interp_envelope[timestep])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sonify.synth_classes.python_synthdefs.Pxx_blob"><code class="flex name class">
<span>class <span class="ident">Pxx_blob</span></span>
<span>(</span><span>pxx, freqs, bins)</span>
</code></dt>
<dd>
<div class="desc"><p>Feature based spectrogram sonification. Synth similar to what was submitted to cancelled ICAD 2020.
Harmonic bands are extracted using peak detection and sonified with sin osc
Spectrogram envelop extracted and sonified using noise sweep</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>synthdef</code></strong> :&ensp;<code>str</code></dt>
<dd>Synthdef saced in sc.sc.synthdefpath - precompiled in supercollider. Default here is Pxx_blob which is similar to the ICAD 2020 submission synth</dd>
<dt><strong><code>freqs</code></strong> :&ensp;<code>1-D numpy array</code></dt>
<dd>Range of frequencies form spectrogram - used for feature detection functions</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>1-D numpy array</code></dt>
<dd>Time bins - needs to be the same as what is in the synthdef (36 bins is convention for spectrograms). Each time bin will have a unique sound, and they are played in sequence to make the sonification</dd>
<dt><strong><code>pxx</code></strong> :&ensp;<code>2-D numpy array</code></dt>
<dd>Spectrogram to be sonified (dimensions freqs.shape x bins.shape)</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>2-D numpy array</code></dt>
<dd>Denotes which oscilators to keep on - the same non-zero entries as pitches. This holds whether the pitch is on or off (dimensions freqs.shape x bins.shape)</dd>
<dt><strong><code>noise</code></strong> :&ensp;<code>1-D numpy array</code></dt>
<dd>Array of cutoff frequencies for the LPF with noise input in supercolider. Computed based on spectrogram envelope.</dd>
<dt><strong><code>pitches</code></strong> :&ensp;<code>2-D numpy array</code></dt>
<dd>Denotes the pitches of the active oscillators. Harmonic sounds are forced by assigning notes of major triad for stacked harmonics. See preprocessing.getPitches for more info</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>2-D numpy array</code></dt>
<dd>for visualizing pitch blob groups</dd>
<dt><strong><code>relativePeakHeight</code></strong> :&ensp;<code>2-D numpy array</code></dt>
<dd>Height of detected spectrogram bands with respect to overall power falloff. Used to control panning in synthdef</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pxx_blob(synth.precompute):
        &#34;&#34;&#34;
        Feature based spectrogram sonification. Synth similar to what was submitted to cancelled ICAD 2020.
        Harmonic bands are extracted using peak detection and sonified with sin osc
        Spectrogram envelop extracted and sonified using noise sweep

        Attributes
        -----------------
        synthdef : str
                Synthdef saced in sc.sc.synthdefpath - precompiled in supercollider. Default here is Pxx_blob which is similar to the ICAD 2020 submission synth
        
        freqs : 1-D numpy array  
                Range of frequencies form spectrogram - used for feature detection functions

        bins : 1-D numpy array
                Time bins - needs to be the same as what is in the synthdef (36 bins is convention for spectrograms). Each time bin will have a unique sound, and they are played in sequence to make the sonification

        pxx : 2-D numpy array 
                Spectrogram to be sonified (dimensions freqs.shape x bins.shape)

        active : 2-D numpy array 
                Denotes which oscilators to keep on - the same non-zero entries as pitches. This holds whether the pitch is on or off (dimensions freqs.shape x bins.shape)
 
        noise : 1-D numpy array
                Array of cutoff frequencies for the LPF with noise input in supercolider. Computed based on spectrogram envelope.

        pitches : 2-D numpy array
                Denotes the pitches of the active oscillators. Harmonic sounds are forced by assigning notes of major triad for stacked harmonics. See preprocessing.getPitches for more info

        labels : 2-D numpy array
                for visualizing pitch blob groups

        relativePeakHeight: 2-D numpy array
                Height of detected spectrogram bands with respect to overall power falloff. Used to control panning in synthdef
        &#34;&#34;&#34;

        def __init__(self, pxx, freqs, bins):
                super().__init__()
                self.synthdef = &#39;Pxx_blob&#39;
                self.freqs = freqs
                self.bins  = bins

                self.pxx = pxx
                self.active = None
                self.noise = None
                self.pitches = None
                self.labels = None
                self.relativePeakHeight = None

                self.generate_synthlist()

        def send_to_sc(self):
                &#34;&#34;&#34;
                Detect features and send the matricies to supercollider
                Important to note that you cannot iterate over numpy arrays to send to sc -- must be converted to a list first
                &#34;&#34;&#34;
                self.active,self.noise,self.pitches, self.labels, self.relativePeakHeight  =  get_Pxx_blob_features(self.pxx.copy(),self.freqs)

                freqs = self.freqs.tolist()
                cut_row = self.noise.tolist()
                n_bins = len(self.bins)

                for idx,syn in enumerate(self.synthlist):
                        if idx &lt; self.freqs.shape[0]:
                                pxx_row = self.relativePeakHeight[idx].tolist()
                                act_row = self.active[idx].tolist()                             #which harmonics are active
                                pitch_row = self.pitches[idx].tolist()                          #pitch of active harmonics
                                syn.timestretch = self.looptime

                                param_names     = [&#39;cut_&#39;,&#39;pxx_&#39;,&#39;act_&#39;,&#39;ph_&#39;]
                                param_values    = [cut_row,pxx_row,act_row,pitch_row]

                        #exception (i.e., if there are more synths in the synthlist than there are spectrogram dimensions) if envelope synth (eg., click) is to be appeneded to the end of synthlist 
                        else:
                                param_name = &#39;cut_&#39;
                                param_value = cut_row

                        for param_name,param_value in zip(param_names,param_values): #this loop replaces the hardcoding of each time bin. This is where we set the class attributes on the sc server
                                names = [f&#39;{param_name}{str(step).zfill(3)}&#39; for step in range(n_bins)]
                                for name,value in zip(names,param_value):
                                        syn.__setattr__(name,value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sonify.synth_classes.synth.precompute" href="synth.html#sonify.synth_classes.synth.precompute">precompute</a></li>
<li><a title="sonify.synth_classes.synth.synth" href="synth.html#sonify.synth_classes.synth.synth">synth</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sonify.synth_classes.python_synthdefs.Pxx_blob.send_to_sc"><code class="name flex">
<span>def <span class="ident">send_to_sc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect features and send the matricies to supercollider
Important to note that you cannot iterate over numpy arrays to send to sc &ndash; must be converted to a list first</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_sc(self):
        &#34;&#34;&#34;
        Detect features and send the matricies to supercollider
        Important to note that you cannot iterate over numpy arrays to send to sc -- must be converted to a list first
        &#34;&#34;&#34;
        self.active,self.noise,self.pitches, self.labels, self.relativePeakHeight  =  get_Pxx_blob_features(self.pxx.copy(),self.freqs)

        freqs = self.freqs.tolist()
        cut_row = self.noise.tolist()
        n_bins = len(self.bins)

        for idx,syn in enumerate(self.synthlist):
                if idx &lt; self.freqs.shape[0]:
                        pxx_row = self.relativePeakHeight[idx].tolist()
                        act_row = self.active[idx].tolist()                             #which harmonics are active
                        pitch_row = self.pitches[idx].tolist()                          #pitch of active harmonics
                        syn.timestretch = self.looptime

                        param_names     = [&#39;cut_&#39;,&#39;pxx_&#39;,&#39;act_&#39;,&#39;ph_&#39;]
                        param_values    = [cut_row,pxx_row,act_row,pitch_row]

                #exception (i.e., if there are more synths in the synthlist than there are spectrogram dimensions) if envelope synth (eg., click) is to be appeneded to the end of synthlist 
                else:
                        param_name = &#39;cut_&#39;
                        param_value = cut_row

                for param_name,param_value in zip(param_names,param_values): #this loop replaces the hardcoding of each time bin. This is where we set the class attributes on the sc server
                        names = [f&#39;{param_name}{str(step).zfill(3)}&#39; for step in range(n_bins)]
                        for name,value in zip(names,param_value):
                                syn.__setattr__(name,value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sonify.synth_classes.synth.precompute" href="synth.html#sonify.synth_classes.synth.precompute">precompute</a></b></code>:
<ul class="hlist">
<li><code><a title="sonify.synth_classes.synth.precompute.add_synth" href="synth.html#sonify.synth_classes.synth.synth.add_synth">add_synth</a></code></li>
<li><code><a title="sonify.synth_classes.synth.precompute.append_synths" href="synth.html#sonify.synth_classes.synth.synth.append_synths">append_synths</a></code></li>
<li><code><a title="sonify.synth_classes.synth.precompute.close_gate" href="synth.html#sonify.synth_classes.synth.precompute.close_gate">close_gate</a></code></li>
<li><code><a title="sonify.synth_classes.synth.precompute.free" href="synth.html#sonify.synth_classes.synth.synth.free">free</a></code></li>
<li><code><a title="sonify.synth_classes.synth.precompute.generate_synthlist" href="synth.html#sonify.synth_classes.synth.synth.generate_synthlist">generate_synthlist</a></code></li>
<li><code><a title="sonify.synth_classes.synth.precompute.get_input_device_number" href="synth.html#sonify.synth_classes.synth.synth.get_input_device_number">get_input_device_number</a></code></li>
<li><code><a title="sonify.synth_classes.synth.precompute.listen" href="synth.html#sonify.synth_classes.synth.precompute.listen">listen</a></code></li>
<li><code><a title="sonify.synth_classes.synth.precompute.open_gate" href="synth.html#sonify.synth_classes.synth.precompute.open_gate">open_gate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sonify.synth_classes.python_synthdefs.flat_q_with_spectro_env"><code class="flex name class">
<span>class <span class="ident">flat_q_with_spectro_env</span></span>
<span>(</span><span>q_array, r_array, pxx, bins, freqs)</span>
</code></dt>
<dd>
<div class="desc"><p>Docs</p>
<p>its more pseudo realtime &ndash; because assumes precomputed on client (python) side
maybe there is a way to mnake it flexible to also just get realtime datastream from python
though this isn't reall useful?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class flat_q_with_spectro_env(synth.realtime):

        def __init__(self,q_array,r_array,pxx,bins,freqs):
                super().__init__()
                self.synthdef = &#39;flat_q_with_spectro_env&#39;

                self.q_array = q_array
                self.r_array = r_array
                
                self.pxx = pxx
                self.bins = bins

                self.n_positions = q_array.shape[0]
                
                positions = np.linspace(0,1,int(self.n_positions/2) + 1) #temp variable
                self.positions = np.append(positions,-1*np.flip(positions[1:-1]))

                self.n_timesteps = q_array.shape[1]

                _, self.envelope,_,_,_ = get_Pxx_blob_features(self.pxx.copy(),freqs) #this is probably an uncessary bottleneck - just compute envelope directly in future

                #rescale and interpolate cutoff frequency envelope over all video frames
                self.envelope /=2
                self.interp_envelope = np.interp(np.linspace(0,self.bins.max(),self.n_timesteps),self.bins,self.envelope)

                #just to maintain naming convention - needed for synthlist generation.. sor for the confusion 
                self.freqs = np.zeros(self.n_positions)
                
                self.generate_synthlist()

                #this doesn&#39;t need to be updated in realtime, only computed once, so we&#39;ll do it here
                for each in range (self.n_positions):
                        self.synthlist[each].theta = float(self.positions[each])

        def send_to_sc(self,timestep):
                &#34;&#34;&#34;
                Unlike precompute - this is called multiple times in the loop as recording progresess. 
                Done for each step in range self.n_timesteps -&gt; see synth.realtime for more
                Assumes all computed on python client side
                &#34;&#34;&#34;
                for position,syn in enumerate(self.synthlist):
                        syn.q = float(self.q_array[position][timestep]) #+ interp_envelope[timestep])
                        syn.r = float(self.r_array[position][timestep])
                        syn.e = float(self.interp_envelope[timestep])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sonify.synth_classes.synth.realtime" href="synth.html#sonify.synth_classes.synth.realtime">realtime</a></li>
<li><a title="sonify.synth_classes.synth.synth" href="synth.html#sonify.synth_classes.synth.synth">synth</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sonify.synth_classes.python_synthdefs.flat_q_with_spectro_env.send_to_sc"><code class="name flex">
<span>def <span class="ident">send_to_sc</span></span>(<span>self, timestep)</span>
</code></dt>
<dd>
<div class="desc"><p>Unlike precompute - this is called multiple times in the loop as recording progresess.
Done for each step in range self.n_timesteps -&gt; see synth.realtime for more
Assumes all computed on python client side</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_sc(self,timestep):
        &#34;&#34;&#34;
        Unlike precompute - this is called multiple times in the loop as recording progresess. 
        Done for each step in range self.n_timesteps -&gt; see synth.realtime for more
        Assumes all computed on python client side
        &#34;&#34;&#34;
        for position,syn in enumerate(self.synthlist):
                syn.q = float(self.q_array[position][timestep]) #+ interp_envelope[timestep])
                syn.r = float(self.r_array[position][timestep])
                syn.e = float(self.interp_envelope[timestep])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sonify.synth_classes.synth.realtime" href="synth.html#sonify.synth_classes.synth.realtime">realtime</a></b></code>:
<ul class="hlist">
<li><code><a title="sonify.synth_classes.synth.realtime.add_synth" href="synth.html#sonify.synth_classes.synth.synth.add_synth">add_synth</a></code></li>
<li><code><a title="sonify.synth_classes.synth.realtime.append_synths" href="synth.html#sonify.synth_classes.synth.synth.append_synths">append_synths</a></code></li>
<li><code><a title="sonify.synth_classes.synth.realtime.free" href="synth.html#sonify.synth_classes.synth.synth.free">free</a></code></li>
<li><code><a title="sonify.synth_classes.synth.realtime.generate_synthlist" href="synth.html#sonify.synth_classes.synth.synth.generate_synthlist">generate_synthlist</a></code></li>
<li><code><a title="sonify.synth_classes.synth.realtime.get_input_device_number" href="synth.html#sonify.synth_classes.synth.synth.get_input_device_number">get_input_device_number</a></code></li>
<li><code><a title="sonify.synth_classes.synth.realtime.listen" href="synth.html#sonify.synth_classes.synth.realtime.listen">listen</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sonify.synth_classes" href="index.html">sonify.synth_classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sonify.synth_classes.python_synthdefs.Pxx_blob" href="#sonify.synth_classes.python_synthdefs.Pxx_blob">Pxx_blob</a></code></h4>
<ul class="">
<li><code><a title="sonify.synth_classes.python_synthdefs.Pxx_blob.send_to_sc" href="#sonify.synth_classes.python_synthdefs.Pxx_blob.send_to_sc">send_to_sc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sonify.synth_classes.python_synthdefs.flat_q_with_spectro_env" href="#sonify.synth_classes.python_synthdefs.flat_q_with_spectro_env">flat_q_with_spectro_env</a></code></h4>
<ul class="">
<li><code><a title="sonify.synth_classes.python_synthdefs.flat_q_with_spectro_env.send_to_sc" href="#sonify.synth_classes.python_synthdefs.flat_q_with_spectro_env.send_to_sc">send_to_sc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>